package com.ljf.company.day07;

/**
 * @Author 龙江锋
 * @Date 2021/3/6 19:55
 * @Version 1.0
 * 本类用于测试继承中构造方法的使用
 *
 * 总结:
 * 1.子类创建对象时,默认会访问父类的无参构造
 * 2.在构造方法的第一行,都有一条默认语句super();--代表的是调用父类的无参构造
 * 3.当父类没有无参构造时,可以通super调用父类的其他构造方法
 * 4.子类能继承父类的所有属性,但父类的私有属性,子类只是拥有,无法使用
 *
 **********************************************************************************
 *
 * 9.1 this与super的区别
 * 1) This代表本类对象的引用
 * class Father3{ this.XXX } //this -- Father3 this = new Father3();
 * 2) super代表父类对象的引用
 * class Father3{ super.XXX } //this -- Father3 super = new Father3();
 * 就相当于创建了一个父类对象
 *
 **********************************************************************************
 *
 * 3) this 可以在两个变量名相同时使用,用于区分成员变量和局部变量
 * 4) this 可以在本类的构造方法之间调用,位置必须是第一条语句,注意,不能相互调用,会死循环
 * 5) super是发生了继承关系以后,子类如果想用父类的功能,可以通过super调用
 * 6) 如果发生了重写,还想用父类的功能,需要使用super来调用
 * 7) Super在调用父类构造方法时,必须出现在子类构造方法的第一条语句,
 *    而且如果父类中没有提供无参构造,子类可以通过super来调用父类其他的含参构造
 *
 **********************************************************************************
 *
 * 9.2 重载Overload 与重写Override的区别
 * 1) 重载: 是指在一个类中的现象,是指一个类中有很多同名的方法,但是方法的参数列表不同
 * 2) 重写: 是指发生了继承关系以后(两个类),子类去修改父类原有的功能,
 *    子类中有一个方法签名(返回值类型 方法名(参数列表) )和父类的一模一样
 * 3) 重载的意义: 是为了方便外界对方法进行调用,什么样的参数程序都可以找到对应的方法来执行,
 *    体现的是程序的灵活性
 * 4) 重写的意义:是在不修改源码的前提下,进行功能的修改和拓展
 *    (OCP原则:面向修改关闭,面向拓展开放)
 * 5) 重写要求方法的修饰符: 子类权限 >= 父类的权限
 */
public class ExtendsPlus {
    public static void main(String[] args) {
        /*我是父类的无参构造123
          我是子类的无参构造方法
          我是父类的无参构造
          我是子类的含参构造方法w
          我是父类的无参构造
          我是父类的无参构造q
        3.创建子类对象进行测试*/
        Son3 s = new Son3();
        //会默认调用父类无参构造
        Son3 s1 = new Son3("w");
        Father3 f = new Father3();
        Father3 f1 = new Father3("q");
    }
}

/** 1.创建父类*/
class Father3{
    /**0.构造方法可以被继承吗?--不可以！！！！！！！！！！！！！！
     * 语法结构的要求:构造方法的方法名需要与本类类名一致,天然就不符合要求*/
    public Father3() {
        System.out.println("我是父类的无参构造");
    }
    public Father3(String n) {
        System.out.println("我是父类的无参构造" + n);
    }
}

/** 2.创建子类*/
class Son3 extends Father3{
    public Son3(){
        /*1.子类的构造方法中,默认存在super(),所以创建子类对象时,默认调用父类的无参构造*/
        /*2.在子类创建对象时,会自动调用子类的无参构造,但是继承后会先去执行父类的无参构造*/
        /*3.当父类中没有无参构造时,调用父类的含参构造*/
        super("123");
        System.out.println("我是子类的无参构造方法");
    }
    public Son3(String s){
        //super();默认存在
        //super("234");
        System.out.println("我是子类的含参构造方法" + s);
    }
}